<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<Class name="iKnow.Converter">
<Super>%iKnow.Source.Converter,Utils.Transform</Super>
<TimeCreated>62992,62458.691554</TimeCreated>

<Method name="BufferString">
<Description><![CDATA[
<p>This method takes the raw input text and buffers it internally in the converter. The text is provided in
chunks of 32k. Every custom converter will need to implement this method so that it can take in the raw
data.</p>]]></Description>
<FormalSpec>data:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Store data in a process-private global
	set ^||%IK.Converter($i(^||%IK.Converter)) = data
	
	quit $$$OK
]]></Implementation>
</Method>

<Method name="Convert">
<Description><![CDATA[
<p>This method is called after all data has been buffered. 
Here we remove text that should not be indexed (such as page numbering, repeating page headers/footers etc.)
If any metadata is present within the document the converter
can extract that metadata here, and provide it to the system. 
Metadata can be reported by using the <method>SetCurrentMetadataValues</method>
function.</p>]]></Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set ^dwconvert($i(^dwconvert))=""
	Kill Rule
	Set Rule($I(Rule))=$Lb($lb($C(13),$C(10),"\E"),$lb($C(10)_$C(13)_$C(10)))
	Set Rule($I(Rule))=$Lb($lb("\E","1:-...-","\E"), $lb(""))
	Set Rule($I(Rule))=$Lb($Lb("\E","2:++...++","\E"), $lb(""))
	Set Rule($I(Rule))=$Lb($lb("\A",",","\A"), $lb(", "))
	Set Rule($I(Rule))=$Lb($lb("\A",".","\A"), $lb(". "))
	Set Rule($I(Rule))=$Lb($lb("\A",",","\D"), $lb(", "))
	Set Rule($I(Rule))=$Lb($lb("\A","(","\A"), $lb("( "))
	Set Rule($I(Rule))=$Lb($lb("\A",")","\A"), $lb(") "))
	Set Rule($I(Rule))=$Lb($lb("\A",")","\D"), $lb(") "))
	Set Rule($I(Rule))=$Lb($lb(",",")","\E"), $lb(" )"))
	Set Rule($I(Rule))=$Lb($lb(")",",","\E"), $lb(" ,"))
	Set Rule($I(Rule))=$Lb($lb(")","(","\E"), $lb(" ("))
	Set Rule($I(Rule))=$Lb($lb(")","/","\E"), $lb(" /"))
	Set Rule($I(Rule))=$Lb($lb("\'D",":","\E"), $lb(": "))
	Set Rule($I(Rule))=$Lb($lb("\'D","/","\E"), $lb("/ "))
	Set Rule($I(Rule))=$Lb($lb("\'D",".","\E"), $lb(". "))
	Set Rule($I(Rule))=$Lb($lb("\E",":","\'D"), $lb(": "))
	Set Rule($I(Rule))=$Lb($lb("\E","/","\'D"), $lb("/ "))
	Set Rule($I(Rule))=$Lb($lb("\E",".","\'D"), $lb(". "))
	Do ..InitTransform(.Rule)
	// Loop over buffered strings
	for i = 1:1:+$g(^||%IK.Converter) {
		
		// prepend space to avoid concatenations
		set str = " "_^||%IK.Converter(i)
		
		set ^dwconvert($i(^dwconvert))=str
		// Fix ligatures
		set tSC=..TransForm(.str) $$$ThrowOnError(tSC)
		
		// Write converted string back to process-private global node
		set ^||%IK.Converter(i) = str
		set ^dwconvert($i(^dwconvert))=str
	}
	
	set ^||%IK.Converter = 0
	quit $$$OK
]]></Implementation>
</Method>

<Method name="NextConvertedPart">
<Description><![CDATA[
<p>When conversion is done, this method will be called to fetch the converted data back from the converter. The method
should return the converted text in chuncks of maximum 32k in size. When no more data is available, the method should
return the empty string ("") to signal that all data has been transferred.</p>]]></Description>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set i = $g(^||%IK.Converter)
	quit:i=""
	
	// skip empty strings as they would appear to end the source
	for {
	    set i = $order(^||%IK.Converter(i), 1, data)
	    quit:i=""
	    
	    // Strip whitespace from converted part
	    set data = $zstrip(data,"<>W")
	   
	    quit:data'=""
	}
	
	if $g(data)="" {
		kill ^||%IK.Converter
		quit ""
	}
	
	set ^||%IK.Converter=i
	
	
	quit data
]]></Implementation>
</Method>
</Class>
</Export>
