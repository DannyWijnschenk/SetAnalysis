<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<Class name="iKnow.XSLExtractor">
<IncludeCode>%occInclude</IncludeCode>
<Super>%XML.XSLT.CallbackHandler</Super>
<TimeCreated>62929,41161.09841</TimeCreated>

<Method name="Process">
<ClassMethod>1</ClassMethod>
<FormalSpec>fn:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	s st=$$$OK
	try {
		s file=##class(%FileCharacterStream).%New(), file.Filename=fn
		s xslt=##class(%Dictionary.CompiledXData).%OpenId(..%ClassName(1)_"||xslt").Data
		s handler=..%New()		
		$$$TOE(st,##class(%XML.XSLT.Transformer).TransformStream(file, xslt, .out,,,handler))
		Set DocSource="?"
		Set PrevLine=""
		While 'out.AtEnd {
			Set len=32000
			Set Line=PrevLine_out.ReadLine(.len,,.eol)
			If len=32000 {
				Set PrevLine=$P(Line,$C(10),$Length(Line,$C(10)))
				Set Line=$P(Line,$C(10),1,$Length(Line,$C(10))-1)
			} else {
				Set PrevLine=""
			}
			If Line="" Continue
			For iPart=1:1:$Length(Line,$C(10)) {
				Do ..ProcessLine(fn, .DocSource, .PrevType, $Piece(Line,$C(10),iPart))
			}
		}
		If PrevLine'="" s ^dwerror($i(^dwerror),"prev")=PrevLine
	} catch ex {
		s st=ex.AsStatus()
		Set inc=$i(^dwerror)
		use 0 write st,!
		Set ^dwerror(inc,"st")=st
	}
	q st
]]></Implementation>
</Method>

<Method name="ProcessLine">
<ClassMethod>1</ClassMethod>
<FormalSpec>XMLFile,DocSource,PrevType,Line</FormalSpec>
<Implementation><![CDATA[
	If Line="" Quit
	Set Type=$Piece(Line,"|",1)
	If (Type="[TEXT-TAG]")!(Type="[RECORD-TAG]")!(Type="[SMOKE-TAG]") {
		Set Data=$Piece(Line,"|",2,999)
		Set PrevType=Type
	} else {
		Set Type=PrevType
		Set Data=Line
	}
	Set Data=$ZCVT(Data,"I","UTF8")

	If Type="[RECORD-TAG]" {
		Set DocId=$I(^||Import)
		Set RecordId=Data
		If RecordId="" Quit  ;todo : raise error
		Set ^||Import(^||Import)=$ListBuild(RecordId)
	} elseif Type="[SMOKE-TAG]" {
		Set Smoke=Data
		Set $List(^||Import(^||Import),2)=Smoke
	} elseif Type="[TEXT-TAG]" {
		Set iText=$I(^||Import(^||Import,"txt"))
		Set ^||Import(^||Import,"txt",iText)=Data
	} else {
		Set ^||Import("err",$I(^||Import("err")))=Data
	}
]]></Implementation>
</Method>

<Method name="evaluate">
<FormalSpec>Args...</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set ^||Text($I(^||Text))="T|"_$Get(Args(1))_"|"_$Get(Args(2))
	q ""
]]></Implementation>
</Method>

<XData name="xslt">
<Data><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xmlns:isc="http://extension-functions.intersystems.com">
<xsl:output method="text"/>
<xsl:template match="/">
<xsl:for-each select="//RECORD[@ID]">
<xsl:choose>
<xsl:when test="//RECORD[@ID]">
[RECORD-TAG]|<xsl:value-of select="@ID"/>
</xsl:when>
</xsl:choose>
<xsl:for-each select="./SMOKING[@STATUS]">
[SMOKE-TAG]|<xsl:value-of select="@STATUS"/>
</xsl:for-each>
<xsl:choose>
<xsl:when test="TEXT">
[TEXT-TAG]|<xsl:value-of select="TEXT"/>
</xsl:when>
</xsl:choose>
</xsl:for-each>
</xsl:template>

</xsl:stylesheet>
]]></Data>
</XData>
</Class>
</Export>
